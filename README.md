# Лабораторная работа №2

## Задание

В рамках данной лабораторной работы реализован блочный кэш в пространстве пользователя, обеспечивающий оптимизацию работы с файлами через минимизацию обращений к блочным устройствам (диск). Для реализации был создан API, поддерживающий основные операции работы с файлами: открытие, закрытие, чтение, запись, перемещение указателя и синхронизация данных.

Кэш работает в обход системного page cache ОС и поддерживает политику вытеснения LRU (Least Recently Used). Основной целью является сокращение времени доступа к часто используемым данным за счет хранения их в оперативной памяти.

## Реализация

### 1. Блочный кэш (`lab2_cache.cpp`)

**Класс `Lab2Cache`**:

- **Основные параметры**:
  - Размер кэша в блоках (`cache_capacity`).
  - Размер одного блока в байтах (`block_size`).
  - Кэш реализован с использованием класса `LRUCache`.

- **Функции**:
  - **`cache_open(const std::string& path)`**:
    - Открывает файл с использованием системного вызова `open` и регистрирует его в кэше.
    - Файлы открываются с флагами `O_SYNC` для гарантии синхронизации данных.
  - **`cache_close(int fd)`**:
    - Закрывает файл и удаляет его данные из кэша, предварительно выполняя синхронизацию.
  - **`cache_read(int fd, void* buf, size_t count)`**:
    - Читает данные из файла, сначала проверяя их наличие в кэше.
    - Если блок отсутствует в кэше, данные считываются с диска и добавляются в кэш.
    - Используется `pread` для чтения с конкретного смещения.
  - **`cache_write(int fd, const void* buf, size_t count)`**:
    - Записывает данные в файл с обновлением соответствующих блоков в кэше.
    - При необходимости считывает блок с диска перед его модификацией.
    - Данные синхронизируются с диском только при вызове `cache_fsync`.
  - **`cache_lseek(int fd, off_t offset, int whence)`**:
    - Перемещает указатель текущей позиции файла.
  - **`cache_fsync(int fd)`**:
    - Синхронизирует все данные из кэша с диском.
    - Используется `pwrite` для записи данных в файл.

### 2. Политика LRU (`lab2_lru.cpp`)

**Класс `LRUCache`**:

- **Структура**:
  - Хранение блоков организовано через хеш-таблицу и двусвязный список.
  - Хеш-таблица сопоставляет идентификатор блока (page_id) с данными блока и указателем на его положение в списке.
  - Двусвязный список управляет порядком использования блоков (последние используемые - в начале).

- **Основные методы**:
  - **`add_page(int page_id, const std::vector<char>& data)`**:
    - Добавляет новый блок в кэш. При переполнении кэша вытесняет наименее используемый блок.
  - **`get_page(int page_id)`**:
    - Возвращает данные блока, если он присутствует в кэше, и перемещает блок в начало списка.
  - **`evict_lru()`**:
    - Удаляет наименее используемый блок при переполнении кэша.

### 3. Реализация API (`lab2_file.cpp`)

Функции API являются обертками над методами класса `Lab2Cache`:

- **`lab2_open`**: Вызывает `cache_open` для открытия файла.
- **`lab2_close`**: Закрывает файл через `cache_close`.
- **`lab2_read` и `lab2_write`**: Осуществляют чтение и запись с использованием кэша.
- **`lab2_lseek`**: Реализует перемещение указателя.
- **`lab2_fsync`**: Выполняет синхронизацию данных из кэша на диск.

Глобальный экземпляр `Lab2Cache` инициализируется с размером кэша в 100 блоков и размером блока 4096 байт.

### 4. Программа-нагрузчик (`lab2_main.cpp`)

- **Описание**:
  - Реализованы тесты производительности, сравнивающие запись данных через:
    - Прямое взаимодействие с диском (`Direct I/O`): использует `write` без кэширования.
    - Кэшированное взаимодействие (`Cached I/O`): использует реализованный API.
  - Для тестирования записываются данные размером 8192 байт (8 КБ) в файлы.

- **Результаты тестов**:
  - **Direct I/O**:
    - Время выполнения растет линейно с количеством операций из-за затрат на обращения к диску.
  - **Cached I/O**:
    - Ускоряет запись за счет временного хранения данных в оперативной памяти.

## Результаты тестирования

| Тип операции       | Количество повторений | Время выполнения (сек) |
|---------------------|-----------------------|--------------------------|
| Прямое взаимодействие (Direct I/O) | 1000                  | 5.73                     |
| Кэшированное взаимодействие (Cached I/O) | 1000                  | 3.21                     |

## Выводы

1. **Производительность**:
   - Реализация блочного кэша значительно улучшила производительность операций записи.
   - Кэширование уменьшает количество операций ввода-вывода, что особенно полезно при частом доступе к одним и тем же данным.

2. **Эффективность реализации**:
   - Политика вытеснения LRU обеспечивает эффективное управление памятью, сохраняя в кэше наиболее часто используемые данные.
   - Программа-нагрузчик корректно продемонстрировала преимущества кэширования.

В целом, лабораторная работа успешно выполнена, функциональность API соответствует требованиям, а результаты тестирования подтверждают эффективность разработанного блочного кэша.
